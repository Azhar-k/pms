# JWT Token Validation Guide

This guide explains how to validate JWT access tokens generated by the User Management Service in your applications.

## Token Information

- **Algorithm**: HMAC-SHA256 (HS256)
- **Token Type**: JWT (JSON Web Token)
- **Secret Key**: Shared secret key (configured in `application.properties`)
- **Token Expiration**: 1 hour (3600 seconds) by default
- **Token Format**: `Bearer <token>` in Authorization header

## Configuration

To validate tokens, you need to share the JWT secret key with your application. The secret key is configured in:

```properties
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
```

**⚠️ Security Note**: In production, use environment variables or a secure configuration management system to share the secret key.

## Validation Methods

### Method 1: Using Token Validation Endpoint (Recommended for Microservices)

The User Management Service provides a token validation endpoint:

```bash
POST /api/v1/token/validate
Authorization: Bearer <your-access-token>
```

**Response (Valid Token):**
```json
{
  "success": true,
  "message": "Operation successful",
  "data": {
    "valid": true,
    "username": "john_doe",
    "message": "Token is valid"
  }
}
```

**Response (Invalid Token):**
```json
{
  "success": true,
  "message": "Operation successful",
  "data": {
    "valid": false,
    "message": "Token is invalid or expired"
  }
}
```

### Method 2: Local Validation (Recommended for High Performance)

Validate tokens locally in your application using the JWT library.

## Code Examples

### Java (Spring Boot)

#### Dependencies (pom.xml)
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.12.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.12.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.12.5</version>
    <scope>runtime</scope>
</dependency>
```

#### JWT Validation Service
```java
package com.yourcompany.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.function.Function;

@Service
public class JwtTokenValidator {

    @Value("${jwt.secret}")
    private String secretKey;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public Boolean validateToken(String token) {
        try {
            extractAllClaims(token);
            return !isTokenExpired(token);
        } catch (Exception e) {
            return false;
        }
    }

    public TokenValidationResult validateTokenWithDetails(String token) {
        try {
            Claims claims = extractAllClaims(token);
            String username = claims.getSubject();
            Date expiration = claims.getExpiration();
            boolean expired = expiration.before(new Date());
            
            return TokenValidationResult.builder()
                    .valid(!expired)
                    .username(username)
                    .expired(expired)
                    .expiresAt(expiration)
                    .build();
        } catch (Exception e) {
            return TokenValidationResult.builder()
                    .valid(false)
                    .error(e.getMessage())
                    .build();
        }
    }
}
```

#### Token Validation Result DTO
```java
package com.yourcompany.dto;

import lombok.Builder;
import lombok.Data;

import java.util.Date;

@Data
@Builder
public class TokenValidationResult {
    private boolean valid;
    private String username;
    private boolean expired;
    private Date expiresAt;
    private String error;
}
```

#### Usage in Controller/Filter
```java
@RestController
public class YourController {

    @Autowired
    private JwtTokenValidator jwtTokenValidator;

    @GetMapping("/protected")
    public ResponseEntity<?> protectedEndpoint(
            @RequestHeader("Authorization") String authHeader) {
        
        String token = authHeader.replace("Bearer ", "").trim();
        
        if (!jwtTokenValidator.validateToken(token)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body("Invalid or expired token");
        }
        
        String username = jwtTokenValidator.extractUsername(token);
        // Your business logic here
        return ResponseEntity.ok("Hello " + username);
    }
}
```

## Token Structure

A JWT token consists of three parts separated by dots (`.`):
1. **Header**: Algorithm and token type
2. **Payload**: Claims (username, expiration, etc.)
3. **Signature**: HMAC signature

Example token payload (decoded):
```json
{
  "sub": "john_doe",
  "iat": 1699876543,
  "exp": 1699880143
}
```

- `sub`: Subject (username)
- `iat`: Issued at (timestamp)
- `exp`: Expiration (timestamp)

## Security Best Practices

1. **Always use HTTPS** in production to protect tokens in transit
2. **Store secret key securely** - Use environment variables or secret management systems
3. **Validate token expiration** - Always check the `exp` claim
4. **Handle token errors gracefully** - Return appropriate HTTP status codes
5. **Log security events** - Log failed validation attempts
6. **Use short token expiration** - Default is 1 hour, adjust as needed
7. **Implement token refresh** - Use refresh tokens for long-lived sessions

## Environment Variables

Set the JWT secret in your application:

```bash
# Linux/Mac
export JWT_SECRET=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Windows
set JWT_SECRET=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
```

## Testing Token Validation

### Using curl
```bash
# Get a token first (login)
TOKEN=$(curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"usernameOrEmail":"admin","password":"Admin@123"}' \
  | jq -r '.data.accessToken')

# Validate token using validation endpoint
curl -X POST http://localhost:8080/api/v1/token/validate \
  -H "Authorization: Bearer $TOKEN"

# Get token info
curl -X GET http://localhost:8080/api/v1/token/info \
  -H "Authorization: Bearer $TOKEN"
```

## Troubleshooting

### Common Issues

1. **"Invalid token" error**
   - Check if the secret key matches exactly
   - Verify the token format (should start with "Bearer ")
   - Ensure the token hasn't been tampered with

2. **"Token expired" error**
   - Token has passed its expiration time
   - Request a new token using the refresh token endpoint

3. **"Signature verification failed"**
   - Secret key mismatch between services
   - Token was signed with a different key


